В этом уроке мы рассмотрим систему типов в Java с высоты птичьего полета, не погружаясь в детали. Но сначала ответим на вопрос, зачем вообще про них знать?

В коде мы все время оперируем данными. Эти данные имеют разную природу, могут быть по-разному организованы, что влияет на удобство работы с ними. Типы преследуют нас на каждом шагу, поэтому без них программирование на Java возможно только на очень базовом уровне.

С другой стороны, не пытайтесь запомнить всю эту информацию про типы наизусть — она дается лишь для общего представления. Все важное о типах вы и так выучите в процессе программирования. Глобально, типы данных в Java делятся на две большие группы:

* **Примитивные** — предопределены в Java
* **Ссылочные** или **не примитивные** — создаются самим программистом, за исключением *String* и *Array*

У этих групп есть различия, которые мы разберем позже, когда познакомимся с `null` и объектно-ориентированным программированием. Пока достаточно знать, что имена примитивных типов начинаются с нижнего регистра (`int`), а ссылочных с верхнего (`String`).

Всего в Java восемь примитивных типов данных:

* *byte*
* *short*
* *int*
* *long*
* *float*
* *double*
* *boolean*
* *char*

Рассмотрим первые четыре типа. Это целые числа разного размера:

* *byte* — занимает в памяти 1 байт, значит может хранить числа от -128 до 127
* *short* — занимает в памяти 2 байта
* *int* — занимает в памяти 4 байта
* *long* — занимает в памяти 8 байт

Посмотрим на примере такого кода:

```java
byte x = 3; // Отработает без проблем

// Error: incompatible types: possible lossy conversion from int to byte
byte y = 270;
```

Определение переменной `y` завершилось с ошибкой, потому что мы указали тип *byte*, но присвоили переменной значение *270*, которое выходит за множество допустимых значений.

Возникает закономерный вопрос. Зачем аж четыре типа для хранения чисел? Почему бы не сделать один, в который влезает почти любое большое число?

Технически так сделать можно, но мы находимся в мире инженерных решений. У любого решения всегда есть обратная сторона, поэтому невозможно сделать идеально — придется чем-то пожертвовать. В данном случае, объемом занимаемой памяти. Если оставить только *long*, то программа, активно оперирующая числами, начнет занимать слишком много места в оперативной памяти, что может быть критично.

Такая же логика использовалась для типов *float* и *double*. Они оба отвечают за рациональные числа. Разница лишь в том, что *double* — это двойной *float*, то есть в памяти он занимает в два раза больше места.

Создатели Java полагаются на разумность программистов, на их способность правильно подобрать нужные типы в зависимости от задачи. Для каких-то экстремальных приложений так и происходит, но в типичной разработке все просто. Программисты выбирают *int* для целых чисел и *double* для рациональных.

Рассмотрим оставшиеся типы данных.

Тип *boolean* отвечает за логические значения `true` и `false`. Им посвящен целый раздел, там мы про него и поговорим.

Особняком стоит тип *char* — символ. Это не строка, у него другой способ определения — через одиночные кавычки:

```java
char ch = 'a';

// Error: incompatible types: java.lang.String cannot be converted to char
char ch2 = "b";
```

Строка, состоящая из одного символа — это не символ. Кажется, нелогично, но с точки зрения типов все так и должно быть, со временем вы это прочувствуете.

Извлечение символа из строки извлекает как раз символ, а не строку, состоящую из одного символа:

```java
"hexlet".charAt(1); // 'e'
```

Хорошо, а где тип данных *String* — строка? Дело в том, что она не является примитивным типом. Внутри она представляет собой массив символов. Несмотря на это техническое различие, строки используются наравне с примитивными типами без особых отличий.
